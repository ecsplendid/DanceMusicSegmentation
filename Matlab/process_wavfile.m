function [ avg_shift, matched_tracks, predictions, SC, CT, W, min_w, space, T ] = process_wavfile( ...
            showname, sampleRate, indexes, audio_low, secondsPerTile, ...
            minTrackLength, maxExpectedTrackWidth, bandwidth, lowPassFilter, highPassFilter, ...
            drawsimmat, solution_shift, gaussian_filterdegree, ...
            use_costsymmetrysum, use_costsymmetrydiff, use_costsymmetry, ...
            use_costcontigpast, use_costcontigfuture, use_costsum, use_costgaussian, ...
            costsymmetrysum_incentivebalance, costsymmetry_incentivebalance, ...
            costcontigfuture_incentivebalance, costcontigpast_incentivebalance, ...
            costsymmetrydiff_incentivebalance, costsum_incentivebalance, costgauss_incentivebalance,  ...
            use_costcontigevolution, costevolution_incentivebalance, ...
            use_cosinecache, contig_windowsize, use_costgaussianwidth, cosine_normalization )

global W;
global CT;

% todo, cache the "last" 6 things this was called with to give a 
% big speed up on the parameter search
[CT, W, tileWidthSecs, space] = get_cosinematrix(...
    audio_low, secondsPerTile, sampleRate,...
    lowPassFilter, highPassFilter, bandwidth, maxExpectedTrackWidth, ...
    gaussian_filterdegree, cosine_normalization );

clear audio_low;
    
% do the cosine normalization (out here so its not cached)

CT = CT.^cosine_normalization;

% we do the normalization manually to keep it centered
CT = (CT.*2)-1; 

%%

global min_w;

% minimum track length in tiles
min_w = floor((minTrackLength) / tileWidthSecs);
global T;

T = size(CT,1);

SC = zeros( T, W );

%contig_windowsize = ceil(contig_windowsize / tileWidthSecs);

if( use_costcontigevolution > 0 )
    
    SC = SC + getcost_contigdiag1( ...
        T, CT, W, min_w, ...
         costevolution_incentivebalance ...
        ) .* use_costcontigevolution;   
end

if( use_costsymmetrysum > 0 )
    
    SC = SC + getcost_symmetrysum( ...
        T, CT, W, min_w, ...
         costsymmetrysum_incentivebalance ...
        ) .* use_costsymmetrysum;   
end

if( use_costsymmetrydiff > 0 )
    
    SC = SC + getcost_symmetrydiff( ...
        T, CT, W, min_w, ...
         costsymmetrydiff_incentivebalance ...
        ) .* use_costsymmetrydiff;   
end

if( use_costsymmetry > 0 )
    
    SC = SC + getcost_symmetry3( ...
        T, CT, W, min_w, ...
         costsymmetry_incentivebalance ...
        ) .* use_costsymmetry;   
end

if( use_costcontigfuture > 0 )
    
    SC = SC + getcost_contigstatic( ...
        T, CT, W, min_w, ...
         costcontigfuture_incentivebalance, contig_windowsize, 1 ...
        ) .* use_costcontigfuture;   
end

if( use_costcontigpast > 0 )
    
    SC = SC + getcost_contigstatic( ...
        T, CT, W, min_w, ...
         costcontigpast_incentivebalance, contig_windowsize, 0 ...
        ) .* use_costcontigpast;   
end

if( use_costgaussian > 0 )
    
    SC = SC + getcost_gaussian( T, W, min_w, ...
         use_costgaussianwidth, costgauss_incentivebalance ) ...
        .* use_costgaussian;
    
end

if( use_costsum > 0 )
    
    SC = SC + (getcost_sum3( T, CT, W, min_w, costsum_incentivebalance ) .* use_costsum);

end

[predictions, matched_tracks, avg_shift] = compute_trackplacement( ...
        showname, SC, drawsimmat, space, indexes, solution_shift, tileWidthSecs, CT, min_w, ...
        secondsPerTile, use_costsymmetrysum, use_costsymmetrydiff, use_costsymmetry, ...
            use_costcontigpast, use_costcontigfuture, use_costsum, use_costgaussian, ...
            costsymmetrysum_incentivebalance, costsymmetry_incentivebalance, ...
            costcontigfuture_incentivebalance, costcontigpast_incentivebalance, ...
            costsymmetrydiff_incentivebalance, costsum_incentivebalance, ...
            costgauss_incentivebalance, use_costcontigevolution, ...
            costevolution_incentivebalance, contig_windowsize, cosine_normalization );
 
%%
end
